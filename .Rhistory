# The R square score.
fityb2$R_square
# The adjusted R square
fityb2$Adj_R_square
# The F statistic
fityb2$F_statistic
# The coefficient of the variables in the model
fityb2$coef
# p value of F-statistic
fityb2$p_value_F
X = as.matrix(example_data2[,2:4])
Y = as.matrix(example_data2[,1])
#fit1 is the result generated by lm()
fit2 = lm(Y~X + 0,data = example_data2)
#fityb is the result generated by yblm()
fityb2 = yblm(X,Y)
# A matrix containing value, Estimate standard error, t value and Pr(>|t|) of each coefficients
fityb2$coef_matrix
# The predicted values by the model
fityb2$predict
# The residuals, which is response minus predicted values.
fityb2$residual
# Sum of residuals
fityb2$SS_X
# The residual degree of freedom.
fityb2$R_df
# The degree of freedom between groups.
fityb2$M_df
# The standard error of the residual
fityb2$RSE
# The R square score.
fityb2$R_square
# The adjusted R square
fityb2$Adj_R_square
# The F statistic
fityb2$F_statistic
# The coefficient of the variables in the model
fityb2$coef
# p value of F-statistic
fityb2$p_value_F
#----------------------------------------Test result when we have no intercept--------------------
test_that("yblm returns correct coefficient", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$coef), unname(fit2$coefficients),tolerance = tolerance)
})
test_that("yblm returns correct predicted value", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$predict), unname(fit2$fitted.values),tolerance = tolerance)
})
test_that("yblm returns correct residual value", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$residual), unname(fit2$residuals),tolerance = tolerance)
})
test_that("yblm returns correct residual degree of freedom", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$R_df), unname(fit2$df.residual),tolerance = tolerance)
})
test_that("yblm returns correct degree of freedom between groups", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$M_df), unname(sum(anova(fit2)[1]) - fit2$df.residual),tolerance = tolerance)
})
test_that("yblm returns correct R_square", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$R_square),as.numeric(summary(fit2)[8]) ,tolerance = tolerance)
})
test_that("yblm returns correct Adj_R_square", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$Adj_R_square), as.numeric(summary(fit2)[9]),tolerance = tolerance)
})
test_that("yblm returns correct F_statistic", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$F_statistic), unname(summary(fit2)$fstatistic["value"]),tolerance = tolerance)
})
test_that("yblm returns correct F_statistic p value", {
tolerance = 1e-12
F_p_value <- pf(summary(fit2)$fstatistic[1], summary(fit2)$fstatistic[2], summary(fit2)$fstatistic[3], lower.tail = FALSE)
expect_equal(as.numeric(fityb2$p_value_F), unname(F_p_value),tolerance = tolerance)
})
test_that("yblm returns correct coefficient matrix", {
tolerance = 1e-12
expect_equal(unname(fityb2$coef_matrix), unname(summary(fit2)$coefficients),tolerance = tolerance)
})
start = Sys.time()
fit2 = lm(Y~X+0,data = example_data1)
end = Sys.time()
fit2_speed = end - start
#fityb is the result generated by yblm()
start2 = Sys.time()
fityb1 = yblm(X,Y)
end2 = Sys.time()
ybfit2_speed = end2 - start2
ybfit2_speed - fit1_speed
data_iris = iris
X = as.matrix(data_iris[,2:4])
Y = as.matrix(data_iris[,1])
#fit1 is the result generated by lm()
fit3 = lm(Y~X + 0,data = example_data2)
anova1 = anova(fit3)
#fityb is the result generated by yblm()
fityb3 = yblm(X,Y)
ybanova = ybanova(fityb3)
data_iris = iris
X = as.matrix(data_iris[,2:4])
Y = as.matrix(data_iris[,1])
#fit1 is the result generated by lm()
fit3 = lm(Y~X + 0,data = example_data2)
anova1 = anova(fit3)
#fityb is the result generated by yblm()
fityb3 = yblm(X,Y)
ybanova = ybanova(fityb3)
ybanova
anova1
anova1
ybanova
anova1[1]
class(anova1)
as.matrix(anova1)
as.matrix(anova1)[,1]
class(ybanova)
as.matrix(ybanova)
as.numeric(as.matrix(ybanova))
as.numeric(as.matrix(ybanova)[,-1])
expect_equal(as.numeric(as.matrix(ybanova)[,-1]), as.numeric(as.matrix(anova1)),tolerance = tolerance)
test_that("yblm returns correct table", {
tolerance = 1e-5
expect_equal(as.numeric(as.matrix(ybanova)[,-1]), as.numeric(as.matrix(anova1)),tolerance = tolerance)
})
test_that("yblm returns correct table", {
tolerance = 1e-5
expect_equal(as.numeric(as.matrix(ybanova)[,-1]), as.numeric(as.matrix(anova1)),tolerance = tolerance)
})
start = Sys.time()
anova1 = anova(fit3)
end = Sys.time()
fit2_speed = end - start
#fityb is the result generated by yblm()
start2 = Sys.time()
ybanova = ybanova(fityb3)
end2 = Sys.time()
ybfit2_speed = end2 - start2
ybfit2_speed - fit1_speed
X1 = rnorm(1000,0,1)
X2 = rnorm(1000,2,1)
X3 = rnorm(1000,4,2)
Y = rnorm(1000,2,3)
X = as.matrix(c(X1,X2,X3),ncol = 3)
Y = as.matrix(Y,ncol = 1)
#fit1 is the result generated by lm()
fit4 = lm(Y~X,data = example_data2)
#fit1 is the result generated by lm()
fit4 = lm(Y ~ X,data = data.frame(cbind(X,Y)))
dim(X)
X = as.matrix(c(X1,X2,X3),ncol = 3)
dim(X)
X = matrix(c(X1,X2,X3),ncol = 3)
Y = matrix(Y,ncol = 1)
#fit1 is the result generated by lm()
fit4 = lm(Y ~ X,data = data.frame(cbind(X,Y)))
anova2 = anova(fit4)
#fityb is the result generated by yblm()
fityb4 = yblm(X,Y,T)
ybanova2 = ybanova(fityb4)
ybanova2
test_that("yblm returns correct table", {
tolerance = 1e-5
expect_equal(as.numeric(as.matrix(ybanova2)[,-1]), as.numeric(as.matrix(anova2)),tolerance = tolerance)
})
start = Sys.time()
anova2 = anova(fit4)
end = Sys.time()
fit2_speed = end - start
#fityb is the result generated by yblm()
start2 = Sys.time()
ybanov2 = ybanova(fityb4)
end2 = Sys.time()
ybfit2_speed = end2 - start2
ybfit2_speed - fit1_speed
X
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(ybLN)
library(bench)
library(ybLN)
library(bench)
example_data1 = sampledata
example_data1
X = as.matrix(example_data1[,1:3])
Y = as.matrix(example_data1[,4])
#fit1 is the result generated by lm()
fit1 = lm(Y~X,data = example_data1)
#fityb is the result generated by yblm()
fityb1 = yblm(X,Y,TRUE)
# A matrix containing value, Estimate standard error, t value and Pr(>|t|) of each coefficients
fityb1$coef_matrix
# The predicted values by the model
fityb1$predict
# The residuals, which is response minus predicted values.
fityb1$residual
# Sum of residuals
fityb1$SS_X
# The residual degree of freedom.
fityb1$R_df
# The degree of freedom between groups.
fityb1$M_df
# The standard error of the residual
fityb1$RSE
# The R square score.
fityb1$R_square
# The adjusted R square
fityb1$Adj_R_square
# The F statistic
fityb1$F_statistic
# The coefficient of the variables in the model
fityb1$coef
# p value of F-statistic
fityb1$p_value_F
X = as.matrix(example_data1[,1:3])
Y = as.matrix(example_data1[,4])
#fit1 is the result generated by lm()
fit1 = lm(Y~X,data = example_data1)
#fityb is the result generated by yblm()
fityb1 = yblm(X,Y,TRUE)
# A matrix containing value, Estimate standard error, t value and Pr(>|t|) of each coefficients
fityb1$coef_matrix
# The predicted values by the model
fityb1$predict
# The residuals, which is response minus predicted values.
fityb1$residual
# Sum of residuals
fityb1$SS_X
# The residual degree of freedom.
fityb1$R_df
# The degree of freedom between groups.
fityb1$M_df
# The standard error of the residual
fityb1$RSE
# The R square score.
fityb1$R_square
# The adjusted R square
fityb1$Adj_R_square
# The F statistic
fityb1$F_statistic
# The coefficient of the variables in the model
fityb1$coef
# p value of F-statistic
fityb1$p_value_F
library(testthat)
#----------------------------------------Test result when we have intercept--------------------
test_that("yblm returns correct coefficient", {
tolerance = 1e-12
expect_equal(as.numeric(fityb1$coef), unname(fit1$coefficients),tolerance = tolerance)
})
test_that("yblm returns correct predicted value", {
tolerance = 1e-12
expect_equal(as.numeric(fityb1$predict), unname(fit1$fitted.values),tolerance = tolerance)
})
test_that("yblm returns correct residual value", {
tolerance = 1e-12
expect_equal(as.numeric(fityb1$residual), unname(fit1$residuals),tolerance = tolerance)
})
test_that("yblm returns correct residual degree of freedom", {
tolerance = 1e-12
expect_equal(as.numeric(fityb1$R_df), unname(fit1$df.residual),tolerance = tolerance)
})
test_that("yblm returns correct degree of freedom between groups", {
tolerance = 1e-12
expect_equal(as.numeric(fityb1$M_df), unname(sum(anova(fit1)[1]) - fit1$df.residual),tolerance = tolerance)
})
test_that("yblm returns correct R_square", {
tolerance = 1e-12
expect_equal(as.numeric(fityb1$R_square),as.numeric(summary(fit1)[8]) ,tolerance = tolerance)
})
test_that("yblm returns correct Adj_R_square", {
tolerance = 1e-12
expect_equal(as.numeric(fityb1$Adj_R_square), as.numeric(summary(fit1)[9]),tolerance = tolerance)
})
test_that("yblm returns correct F_statistic", {
tolerance = 1e-12
expect_equal(as.numeric(fityb1$F_statistic), unname(summary(fit1)$fstatistic["value"]),tolerance = tolerance)
})
test_that("yblm returns correct F_statistic p value", {
tolerance = 1e-5
F_p_value <- pf(summary(fit1)$fstatistic[1], summary(fit1)$fstatistic[2], summary(fit1)$fstatistic[3], lower.tail = FALSE)
expect_equal(as.numeric(fityb1$p_value_F), unname(F_p_value),tolerance = tolerance)
})
test_that("yblm returns correct coefficient matrix", {
tolerance = 1e-12
expect_equal(unname(fityb1$coef_matrix), unname(summary(fit1)$coefficients),tolerance = tolerance)
})
start = Sys.time()
fit1 = lm(Y~X,data = example_data1)
end = Sys.time()
fit1_speed = end - start
#fityb is the result generated by yblm()
start2 = Sys.time()
fityb1 = yblm(X,Y,TRUE)
end2 = Sys.time()
ybfit_speed = end2 - start2
ybfit_speed - fit1_speed
example_data2 = iris
example_data2
X = as.matrix(example_data2[,2:4])
Y = as.matrix(example_data2[,1])
#fit1 is the result generated by lm()
fit2 = lm(Y~X + 0,data = example_data2)
#fityb is the result generated by yblm()
fityb2 = yblm(X,Y)
# A matrix containing value, Estimate standard error, t value and Pr(>|t|) of each coefficients
fityb2$coef_matrix
# The predicted values by the model
fityb2$predict
# The residuals, which is response minus predicted values.
fityb2$residual
# Sum of residuals
fityb2$SS_X
# The residual degree of freedom.
fityb2$R_df
# The degree of freedom between groups.
fityb2$M_df
# The standard error of the residual
fityb2$RSE
# The R square score.
fityb2$R_square
# The adjusted R square
fityb2$Adj_R_square
# The F statistic
fityb2$F_statistic
# The coefficient of the variables in the model
fityb2$coef
# p value of F-statistic
fityb2$p_value_F
#----------------------------------------Test result when we have no intercept--------------------
test_that("yblm returns correct coefficient", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$coef), unname(fit2$coefficients),tolerance = tolerance)
})
test_that("yblm returns correct predicted value", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$predict), unname(fit2$fitted.values),tolerance = tolerance)
})
test_that("yblm returns correct residual value", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$residual), unname(fit2$residuals),tolerance = tolerance)
})
test_that("yblm returns correct residual degree of freedom", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$R_df), unname(fit2$df.residual),tolerance = tolerance)
})
test_that("yblm returns correct degree of freedom between groups", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$M_df), unname(sum(anova(fit2)[1]) - fit2$df.residual),tolerance = tolerance)
})
test_that("yblm returns correct R_square", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$R_square),as.numeric(summary(fit2)[8]) ,tolerance = tolerance)
})
test_that("yblm returns correct Adj_R_square", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$Adj_R_square), as.numeric(summary(fit2)[9]),tolerance = tolerance)
})
test_that("yblm returns correct F_statistic", {
tolerance = 1e-12
expect_equal(as.numeric(fityb2$F_statistic), unname(summary(fit2)$fstatistic["value"]),tolerance = tolerance)
})
test_that("yblm returns correct F_statistic p value", {
tolerance = 1e-12
F_p_value <- pf(summary(fit2)$fstatistic[1], summary(fit2)$fstatistic[2], summary(fit2)$fstatistic[3], lower.tail = FALSE)
expect_equal(as.numeric(fityb2$p_value_F), unname(F_p_value),tolerance = tolerance)
})
test_that("yblm returns correct coefficient matrix", {
tolerance = 1e-12
expect_equal(unname(fityb2$coef_matrix), unname(summary(fit2)$coefficients),tolerance = tolerance)
})
start = Sys.time()
fit2 = lm(Y~X+0,data = example_data1)
example_data1
start = Sys.time()
fit2 = lm(Y~X1 + X2 + X3+0,data = example_data1)
end = Sys.time()
fit2_speed = end - start
#fityb is the result generated by yblm()
start2 = Sys.time()
fityb1 = yblm(X,Y)
end2 = Sys.time()
ybfit2_speed = end2 - start2
ybfit2_speed - fit1_speed
data_iris = iris
X = as.matrix(data_iris[,2:4])
Y = as.matrix(data_iris[,1])
#fit1 is the result generated by lm()
fit3 = lm(Y~X + 0,data = example_data2)
anova1 = anova(fit3)
#fityb is the result generated by yblm()
fityb3 = yblm(X,Y)
ybanova = ybanova(fityb3)
ybanova
test_that("yblm returns correct table", {
tolerance = 1e-5
expect_equal(as.numeric(as.matrix(ybanova)[,-1]), as.numeric(as.matrix(anova1)),tolerance = tolerance)
})
start = Sys.time()
anova1 = anova(fit3)
end = Sys.time()
fit2_speed = end - start
#fityb is the result generated by yblm()
start2 = Sys.time()
ybanova = ybanova(fityb3)
end2 = Sys.time()
ybfit2_speed = end2 - start2
ybfit2_speed - fit1_speed
library(testthat)
library(ybLN)
library(stats)
data_iris = iris
fit1 = lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width,data = data_iris)
fit2 = lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + 0,data = data_iris)
a1 = anova(fit1)
a2 = anova(fit2)
X = cbind(data_iris$Sepal.Width,data_iris$Petal.Length,data_iris$Petal.Width)
Y = data_iris$Sepal.Length
fityb1 = yblm(X,Y,T)
fityb2 = yblm(X,Y)
yba1 = ybanova(fityb1)
yba2 = ybanova(fityb2)
#----------------------------------------Test result when we have intercept--------------------
test_that("yblm returns correct table", {
tolerance = 1e-5
anova_table = a1[1,] + a1[2,] + a1[3,]
anova_table[3] = anova_table[2]/anova_table[1]
anova_table[4] = anova_table[3]/a1[4,3]
anova_table[5] <- 1 - pf(as.numeric(anova_table[4]), as.numeric(anova_table[1]), as.numeric(a1[4,1]))
temp = as.matrix(rbind(anova_table,a1[4,]))
expect_equal(as.numeric(unname(as.matrix(yba1))[,-1]), as.numeric(unname(temp)),tolerance = tolerance)
})
#----------------------------------------Test result when we have no intercept--------------------
test_that("yblm returns correct table", {
tolerance = 1e-5
anova_table2 = a2[1,] + a2[2,] + a2[3,]
anova_table2[3] = anova_table2[2]/anova_table2[1]
anova_table2[4] = anova_table2[3]/a2[4,3]
anova_table2[5] <- 1 - pf(as.numeric(anova_table2[4]), as.numeric(anova_table2[1]), as.numeric(a2[4,1]))
temp2 = as.matrix(rbind(anova_table2,a2[4,]))
expect_equal(as.numeric(unname(as.matrix(yba2))[,-1]), as.numeric(unname(temp2)),tolerance = tolerance)
})
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
usethis::use_github_actions()
install.packages("usethis")
install.packages("usethis")
library(usethis)
usethis::use_github_actions()
git init
usethis::use_github_actions()
usethis::use_github_actions()
usethis::use_github_actions()
usethis::use_readme_rmd()
usethis::use_github_actions()
usethis::use_github_actions()
usethis::use_coverage()
usethis::use_github_action("test
-coverage")
The `ybanova` function is another version of `anova()` function in R. This function will generate an ANOVA table, which is similar to the R's regular function.
usethis::use_coverage()
usethis::use_github_actions()
usethis::use_coverage()
usethis::use_github_actions()
usethis::use_github_actions()
usethis::use_coverage()
usethis::check-release()
check-release
usethis::use_coverage()
usethis::use_github_actions()
library(ybLN)
devtools::install_github("Megumi-ybb/BIOSTAT625HW3")
sampledata
library(ybLN)
sampledata
devtools::install_github("Megumi-ybb/BIOSTAT625HW3")
usethis::use_testthat()
usethis::use_github_actions()
usethis::use_github_action("test
-coverage")
usethis::use_coverage()
usethis::use_coverage()
usethis::use_github_actions()
usethis::use_github_actions()
usethis::use_github_action_check_standard()
check-standard
check-standard()
add_github_actions_check_badge(organisation = NULL, quiet = FALSE)
add_github_actions_check()
usethis::use_github_action_check_standard()
usethis::use_github_actions()
usethis::use_coverage()
usethis::use_github_action("test
-coverage")
usethis::use_github_action("test-coverage")
git pull
usethis::use_github_action("test-coverage")
usethis::use_github_action("test-coverage")
usethis::use_coverage()
usethis::use_github_action("test-coverage")
usethis::use_coverage()
usethis::use_github_action("test-coverage")
install.packages("covr")
usethis::use_coverage()
usethis::use_github_action("test-coverage")
